---
title: "permutationsってなんやねん"
emoji: "🦀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["rust", "algorithm"]
published: false
---
- 順列のこと
- 最近AtCoderに参加して、詰まる問題のパーツになっている事が多い
- 解説を見てもしれっと `next_permutation()` などと出てきてはい終わり、みたいなことも多い
- 学業で登場するときなどは専ら順列の「数」など個数に着目するが、競プロの題材においては順列の「中身」に着目するんだなぁ

## 概念

- いわゆる「箱の中に1~4の数字が書かれたカードが4枚あり、箱の中から1枚ずつ順番にすべてのカードを取ったときにありうる順番を列挙したもの」というやつ

```txt
+---------+
| box     |
+---------+
| 1,3,4   |
+---------+

+---+
| 2 |
+---+
```

```txt
+---------+
| box     |
+---------+
| 3,4     |
+---------+

+---+---+
| 2 | 1 |
+---+---+
```

```txt
+---------+
| box     |
+---------+
| 3       |
+---------+

+---+---+---+
| 2 | 1 | 4 |
+---+---+---+
```

```txt
+---------+
| box     |
+---------+
|         |
+---------+

+---+---+---+---+
| 2 | 1 | 4 | 3 |
+---+---+---+---+

↑これの取りうるパターンすべてを網羅する
```

## チープな実装で掴む

- ある内容を持つ `Vec` の順列を求める関数を書いてみる

```rust
fn permutations<T: Clone>(v: Vec<T>) -> Vec<Vec<T>> {
    // 継ぎ接ぎしていくので、 LinkedListに変換して進める
    let mut list = LinkedList::from_iter(v.iter().cloned());
    return permutations_core(&mut Vec::new(), &mut list);
}
fn permutations_core<T: Clone>(picked: &mut Vec<T>, list: &mut LinkedList<T>) -> Vec<Vec<T>> {
    if list.len() == 0 {
        return vec![picked.clone()];
    }

    let mut res = Vec::new();

    for i in 0..list.len() {
        let mut after = list.split_off(i);
        if let Some(v) = after.pop_front() {
            picked.push(v);
            list.append(&mut after);
            let mut vv = permutations_core(picked, list);
            res.append(&mut vv);

            // もとに戻す
            let v = picked.pop().unwrap();
            after = list.split_off(i);
            after.push_front(v);
        }
        list.append(&mut after);
    }

    return res;
}
```

- 継ぎ接ぎしやすいよう、 `LinkedList` に変換している
- リストの先頭方向を優先してひとつ取り、再帰的に実行している

### テストを書く

- 正しく振る舞っているか、ひとつひとつテストのassertを増やして確認した

```rust
#[cfg(test)]
mod tests {
    use crate::permutations;

    #[test]
    fn test_permutations() {
        let vv = permutations(vec![1, 2, 3, 4]);

        assert_eq!(vv[0], vec![1, 2, 3, 4]);
        assert_eq!(vv[1], vec![1, 2, 4, 3]);
    }
}
```

- 上述の実装に基づけば `vv[0]` は素直に元の順番で選ばれるはず
- `vv[1]` は3つ目の要素を選ぶときに、`list` の中身 `[3,4]` から `4` を選ぶはずだ
- そのようにして最終的なテストは以下のようになった

```rust
#[cfg(test)]
mod tests {
    use crate::permutations;

    #[test]
    fn test_permutations() {
        let vv = permutations(vec![1, 2, 3, 4]);
        assert_eq!(vv.len(), 24);

        assert_eq!(vv[0], vec![1, 2, 3, 4]);
        assert_eq!(vv[1], vec![1, 2, 4, 3]);
        assert_eq!(vv[2], vec![1, 3, 2, 4]);
        assert_eq!(vv[3], vec![1, 3, 4, 2]);
        assert_eq!(vv[4], vec![1, 4, 2, 3]);
        assert_eq!(vv[5], vec![1, 4, 3, 2]);

        assert_eq!(vv[6], vec![2, 1, 3, 4]);
        assert_eq!(vv[7], vec![2, 1, 4, 3]);
        assert_eq!(vv[8], vec![2, 3, 1, 4]);
        assert_eq!(vv[9], vec![2, 3, 4, 1]);
        assert_eq!(vv[10], vec![2, 4, 1, 3]);
        assert_eq!(vv[11], vec![2, 4, 3, 1]);

        assert_eq!(vv[12], vec![3, 1, 2, 4]);
        assert_eq!(vv[13], vec![3, 1, 4, 2]);
        assert_eq!(vv[14], vec![3, 2, 1, 4]);
        assert_eq!(vv[15], vec![3, 2, 4, 1]);
        assert_eq!(vv[16], vec![3, 4, 1, 2]);
        assert_eq!(vv[17], vec![3, 4, 2, 1]);

        assert_eq!(vv[18], vec![4, 1, 2, 3]);
        assert_eq!(vv[19], vec![4, 1, 3, 2]);
        assert_eq!(vv[20], vec![4, 2, 1, 3]);
        assert_eq!(vv[21], vec![4, 2, 3, 1]);
        assert_eq!(vv[22], vec![4, 3, 1, 2]);
        assert_eq!(vv[23], vec![4, 3, 2, 1]);
    }
}
```

- 4つの数字の集合から4つを選んだときの順列は `4!` 通り、つまり `24` 通り
- assertの内容を観察すると、「入力が昇順ソートされていて、かつ重複がない場合」、得られた結果も昇順ソートされているようにみえる
