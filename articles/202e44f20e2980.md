---
title: "permutationsってなんやねん"
emoji: "🦀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["rust", "algorithm"]
published: false
---
- 順列のこと
- 最近AtCoderに参加して、詰まる問題のパーツになっている事が多い
- 解説を見てもしれっと `next_permutation()` などと出てきてはい終わり、みたいなことも多い
- 学業で登場するときなどは専ら順列の「数」など個数に着目するが、競プロの題材においては順列の「中身」に着目するんだなぁ

## 概念

- いわゆる「箱の中に1~4の数字が書かれたカードが4枚あり、箱の中から1枚ずつ順番にすべてのカードを取ったときにありうる順番を列挙したもの」というやつ

```txt
+---------+
| box     |
+---------+
| 1,3,4   |
+---------+

+---+
| 2 |
+---+
```

```txt
+---------+
| box     |
+---------+
| 3,4     |
+---------+

+---+---+
| 2 | 1 |
+---+---+
```

```txt
+---------+
| box     |
+---------+
| 3       |
+---------+

+---+---+---+
| 2 | 1 | 4 |
+---+---+---+
```

```txt
+---------+
| box     |
+---------+
|         |
+---------+

+---+---+---+---+
| 2 | 1 | 4 | 3 |
+---+---+---+---+

↑これの取りうるパターンすべてを網羅する
```

## チープな実装で掴む

- ある内容を持つ `Vec` の順列を求める関数を書いてみる

```rust
fn permutations<T: Clone>(v: Vec<T>) -> Vec<Vec<T>> {
    // 継ぎ接ぎしていくので、 LinkedListに変換して進める
    let mut list = LinkedList::from_iter(v.iter().cloned());
    return permutations_core(&mut Vec::new(), &mut list);
}
fn permutations_core<T: Clone>(picked: &mut Vec<T>, list: &mut LinkedList<T>) -> Vec<Vec<T>> {
    if list.len() == 0 {
        return vec![picked.clone()];
    }

    let mut res = Vec::new();

    for i in 0..list.len() {
        let mut after = list.split_off(i);
        if let Some(v) = after.pop_front() {
            picked.push(v);
            list.append(&mut after);
            let mut vv = permutations_core(picked, list);
            res.append(&mut vv);

            // もとに戻す
            let v = picked.pop().unwrap();
            after = list.split_off(i);
            after.push_front(v);
        }
        list.append(&mut after);
    }

    return res;
}
```

- 継ぎ接ぎしやすいよう、 `LinkedList` に変換している
- リストの先頭方向を優先してひとつ取り、再帰的に実行している
