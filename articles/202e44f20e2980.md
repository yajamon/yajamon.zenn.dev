---
title: "permutationsã£ã¦ãªã‚“ã‚„ã­ã‚“"
emoji: "ğŸ¦€"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["rust", "algorithm"]
published: false
---
- é †åˆ—ã®ã“ã¨
- æœ€è¿‘AtCoderã«å‚åŠ ã—ã¦ã€è©°ã¾ã‚‹å•é¡Œã®ãƒ‘ãƒ¼ãƒ„ã«ãªã£ã¦ã„ã‚‹äº‹ãŒå¤šã„
- è§£èª¬ã‚’è¦‹ã¦ã‚‚ã—ã‚Œã£ã¨ `next_permutation()` ãªã©ã¨å‡ºã¦ãã¦ã¯ã„çµ‚ã‚ã‚Šã€ã¿ãŸã„ãªã“ã¨ã‚‚å¤šã„
- å­¦æ¥­ã§ç™»å ´ã™ã‚‹ã¨ããªã©ã¯å°‚ã‚‰é †åˆ—ã®ã€Œæ•°ã€ãªã©å€‹æ•°ã«ç€ç›®ã™ã‚‹ãŒã€ç«¶ãƒ—ãƒ­ã®é¡Œæã«ãŠã„ã¦ã¯é †åˆ—ã®ã€Œä¸­èº«ã€ã«ç€ç›®ã™ã‚‹ã‚“ã ãªã

## æ¦‚å¿µ

- ã„ã‚ã‚†ã‚‹ã€Œç®±ã®ä¸­ã«1~4ã®æ•°å­—ãŒæ›¸ã‹ã‚ŒãŸã‚«ãƒ¼ãƒ‰ãŒ4æšã‚ã‚Šã€ç®±ã®ä¸­ã‹ã‚‰1æšãšã¤é †ç•ªã«ã™ã¹ã¦ã®ã‚«ãƒ¼ãƒ‰ã‚’å–ã£ãŸã¨ãã«ã‚ã‚Šã†ã‚‹é †ç•ªã‚’åˆ—æŒ™ã—ãŸã‚‚ã®ã€ã¨ã„ã†ã‚„ã¤

```txt
+---------+
| box     |
+---------+
| 1,3,4   |
+---------+

+---+
| 2 |
+---+
```

```txt
+---------+
| box     |
+---------+
| 3,4     |
+---------+

+---+---+
| 2 | 1 |
+---+---+
```

```txt
+---------+
| box     |
+---------+
| 3       |
+---------+

+---+---+---+
| 2 | 1 | 4 |
+---+---+---+
```

```txt
+---------+
| box     |
+---------+
|         |
+---------+

+---+---+---+---+
| 2 | 1 | 4 | 3 |
+---+---+---+---+

â†‘ã“ã‚Œã®å–ã‚Šã†ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã™ã¹ã¦ã‚’ç¶²ç¾…ã™ã‚‹
```

## ãƒãƒ¼ãƒ—ãªå®Ÿè£…ã§æ´ã‚€

- ã‚ã‚‹å†…å®¹ã‚’æŒã¤ `Vec` ã®é †åˆ—ã‚’æ±‚ã‚ã‚‹é–¢æ•°ã‚’æ›¸ã„ã¦ã¿ã‚‹

```rust
fn permutations<T: Clone>(v: Vec<T>) -> Vec<Vec<T>> {
    // ç¶™ãæ¥ãã—ã¦ã„ãã®ã§ã€ LinkedListã«å¤‰æ›ã—ã¦é€²ã‚ã‚‹
    let mut list = LinkedList::from_iter(v.iter().cloned());
    return permutations_core(&mut Vec::new(), &mut list);
}
fn permutations_core<T: Clone>(picked: &mut Vec<T>, list: &mut LinkedList<T>) -> Vec<Vec<T>> {
    if list.len() == 0 {
        return vec![picked.clone()];
    }

    let mut res = Vec::new();

    for i in 0..list.len() {
        let mut after = list.split_off(i);
        if let Some(v) = after.pop_front() {
            picked.push(v);
            list.append(&mut after);
            let mut vv = permutations_core(picked, list);
            res.append(&mut vv);

            // ã‚‚ã¨ã«æˆ»ã™
            let v = picked.pop().unwrap();
            after = list.split_off(i);
            after.push_front(v);
        }
        list.append(&mut after);
    }

    return res;
}
```

- ç¶™ãæ¥ãã—ã‚„ã™ã„ã‚ˆã†ã€ `LinkedList` ã«å¤‰æ›ã—ã¦ã„ã‚‹
- ãƒªã‚¹ãƒˆã®å…ˆé ­æ–¹å‘ã‚’å„ªå…ˆã—ã¦ã²ã¨ã¤å–ã‚Šã€å†å¸°çš„ã«å®Ÿè¡Œã—ã¦ã„ã‚‹

### ãƒ†ã‚¹ãƒˆã‚’æ›¸ã

- æ­£ã—ãæŒ¯ã‚‹èˆã£ã¦ã„ã‚‹ã‹ã€ã²ã¨ã¤ã²ã¨ã¤ãƒ†ã‚¹ãƒˆã®assertã‚’å¢—ã‚„ã—ã¦ç¢ºèªã—ãŸ

```rust
#[cfg(test)]
mod tests {
    use crate::permutations;

    #[test]
    fn test_permutations() {
        let vv = permutations(vec![1, 2, 3, 4]);

        assert_eq!(vv[0], vec![1, 2, 3, 4]);
        assert_eq!(vv[1], vec![1, 2, 4, 3]);
    }
}
```

- ä¸Šè¿°ã®å®Ÿè£…ã«åŸºã¥ã‘ã° `vv[0]` ã¯ç´ ç›´ã«å…ƒã®é †ç•ªã§é¸ã°ã‚Œã‚‹ã¯ãš
- `vv[1]` ã¯3ã¤ç›®ã®è¦ç´ ã‚’é¸ã¶ã¨ãã«ã€`list` ã®ä¸­èº« `[3,4]` ã‹ã‚‰ `4` ã‚’é¸ã¶ã¯ãšã 
- ãã®ã‚ˆã†ã«ã—ã¦æœ€çµ‚çš„ãªãƒ†ã‚¹ãƒˆã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ãŸ

```rust
#[cfg(test)]
mod tests {
    use crate::permutations;

    #[test]
    fn test_permutations() {
        let vv = permutations(vec![1, 2, 3, 4]);
        assert_eq!(vv.len(), 24);

        assert_eq!(vv[0], vec![1, 2, 3, 4]);
        assert_eq!(vv[1], vec![1, 2, 4, 3]);
        assert_eq!(vv[2], vec![1, 3, 2, 4]);
        assert_eq!(vv[3], vec![1, 3, 4, 2]);
        assert_eq!(vv[4], vec![1, 4, 2, 3]);
        assert_eq!(vv[5], vec![1, 4, 3, 2]);

        assert_eq!(vv[6], vec![2, 1, 3, 4]);
        assert_eq!(vv[7], vec![2, 1, 4, 3]);
        assert_eq!(vv[8], vec![2, 3, 1, 4]);
        assert_eq!(vv[9], vec![2, 3, 4, 1]);
        assert_eq!(vv[10], vec![2, 4, 1, 3]);
        assert_eq!(vv[11], vec![2, 4, 3, 1]);

        assert_eq!(vv[12], vec![3, 1, 2, 4]);
        assert_eq!(vv[13], vec![3, 1, 4, 2]);
        assert_eq!(vv[14], vec![3, 2, 1, 4]);
        assert_eq!(vv[15], vec![3, 2, 4, 1]);
        assert_eq!(vv[16], vec![3, 4, 1, 2]);
        assert_eq!(vv[17], vec![3, 4, 2, 1]);

        assert_eq!(vv[18], vec![4, 1, 2, 3]);
        assert_eq!(vv[19], vec![4, 1, 3, 2]);
        assert_eq!(vv[20], vec![4, 2, 1, 3]);
        assert_eq!(vv[21], vec![4, 2, 3, 1]);
        assert_eq!(vv[22], vec![4, 3, 1, 2]);
        assert_eq!(vv[23], vec![4, 3, 2, 1]);
    }
}
```

- 4ã¤ã®æ•°å­—ã®é›†åˆã‹ã‚‰4ã¤ã‚’é¸ã‚“ã ã¨ãã®é †åˆ—ã¯ `4!` é€šã‚Šã€ã¤ã¾ã‚Š `24` é€šã‚Š
- assertã®å†…å®¹ã‚’è¦³å¯Ÿã™ã‚‹ã¨ã€ã€Œå…¥åŠ›ãŒæ˜‡é †ã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã¦ã€ã‹ã¤é‡è¤‡ãŒãªã„å ´åˆã€ã€å¾—ã‚‰ã‚ŒãŸçµæœã‚‚æ˜‡é †ã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«ã¿ãˆã‚‹

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¯æ‚ªã„

```rust
#[cfg(test)]
mod tests {
    use crate::permutations;
    #[test]
    fn test_permutations_10() {
        let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let vv = permutations(v);
    }
}
// successes:
//    tests::test_permutations_speed
//
// test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 4.20s
```

- assertã¯ãªãã€ãŸã å®Ÿè¡Œã™ã‚‹ã ã‘ã®ãƒ†ã‚¹ãƒˆ
- è¦ç´ ã¯10å€‹ã ãŒã€4ç§’ã‚‚ã‹ã‹ã£ã¦ã—ã¾ã£ã¦ã„ã‚‹
    - `10!` é€šã‚Šã€‚ã™ãªã‚ã¡ `3_628_800` é€šã‚Šã€‚
        - ç§’é–“ `1_000_000` é€šã‚Šãã‚‰ã„ã¯å‡¦ç†å¯èƒ½ã«ãªã£ã¦ã»ã—ã„


## next_permutation ã«è¿‘ã¥ã

- `next_permutation()` ã¯ã€é †åˆ—ã¨ã—ã¦åˆ—æŒ™ã•ã‚ŒãŸé…åˆ—ãŸã¡ã‚’è¾æ›¸é †ã€ã‚ã‚‹ã„ã¯æ˜‡é †ã§ã‚½ãƒ¼ãƒˆã—ãŸçµæœã«ãŠã„ã¦ã€æ¬¡ã®å½¢ã‚’è¿”ã™ã‚‚ã®
    - ä¸Šè¿°ã® `permutations_core()` ã¯ã™ã¹ã¦ã®çµ„ã¿åˆã‚ã›ã‚’ç¶²ç¾…ã™ã‚‹ã¾ã§æ­¢ã¾ã‚‰ãªã„
        - ã¾ãŸã€è¦ç´ ã®é‡è¤‡ã«å¯¾å¿œã—ã¦ã„ãªã„

### è¦ç´ ã®å…¥ã‚Œæ›¿ãˆ

- assertã‚’è¦‹ã‚‹ã¨ã€æœ«å°¾ã‹ã‚‰å…¥ã‚Œæ›¿ãˆã¦ã„ãã¨è‰¯ã•ãã†ã§ã‚ã‚‹

```rust
| 1,2,3,4 |
|     ^ ^ |
|     j i |
â†“ i ã¨ j ã‚’äº¤æ›ã™ã‚‹
| 1,2,4,3 |
```

- ã“ã‚Œä»¥ä¸Šã€`v[3]` ã¨ `v[2]` ã‚’å…¥ã‚Œæ›¿ãˆã¦ã‚‚æ–°ã—ã„é…åˆ—ã¯ç”Ÿã¾ã‚Œãªã„
    - `v[1]` ãŒæ¬¡ã®å€¤ã«ãªã‚‹ã¹ãã ã‚ã†
- æœ«å°¾ã®å€¤ã‹ã‚‰ã€è‡ªèº«ã‚ˆã‚Šå°ã•ã„å€¤ã‚’æ¢ã—ã¦ã„ãã¨ã€ã©ã†ã‚„ã‚‰ `v[1]` ã¨äº¤æ›ã—ãã†ã§ã‚ã‚‹

### ã‚½ãƒ¼ãƒˆã‚’ã‹ã‘ã‚‹ã€ã®ã§ã¯ãªãé€†é †ï¼Ÿ

```rust
| 1,2,4,3 |
|   j   i |
â†“
| 1,3,4,2 |
| 1,3,2,4 | â† æœŸå¾…ã™ã‚‹å½¢
```

- `v[1]` ã¯æœ›ã‚€å½¢ã«ãªã£ãŸãŒã€assertã®é †ç•ªã¨åˆã‚ãªã„
    - `v[2]` ã¨ `v[3]` ã‚’äº¤æ›ã™ã‚Œã°ã„ã„ã€ãã‚Œã ã‘ï¼Ÿ
- ã»ã‹ã®äº‹ä¾‹ã‚‚è¦‹ã‚‹

```rust
| 1,4,3,2 | â† vv[5]
| j     i |
â†“
| 2,4,3,1 | â† äº¤æ›ç›´å¾Œ
| 2,1,3,4 | â† æœŸå¾…ã™ã‚‹å½¢

| 1,5,4,3,2 |
| j       i |
â†“
| 2,5,4,3,1 | â† äº¤æ›ç›´å¾Œ
| 2,1,3,4,5 | â† æœŸå¾…ã™ã‚‹å½¢
```

- ã©ã†ã‚„ã‚‰ã€äº¤æ›ã—ãŸå…ˆã‚ˆã‚Šå¾Œã‚ã®è¦ç´ ã‚’é€†é †ã«ã™ã‚Œã°è‰¯ã•ãã†ã 

### ä¸å…·åˆ

```rust
| 1,3,4,2 |
| j     i |
â†“
| 2,3,4,1 | â† äº¤æ›ç›´å¾Œ
| 2,1,4,3 | â† j+1 ä»¥é™é€†é †
| 1,4,2,3 | â† æœŸå¾…ã™ã‚‹å½¢
```

- æœ«å°¾ã® `2` ã‚ˆã‚Š å†’é ­ã® `1` ã®ã»ã†ãŒå°ã•ã„ã®ã§ã€æœ«å°¾ã‚ˆã‚Šå°ã•ã„ã‚‚ã®ã‚’æ¢ã—ã¦å…¥ã‚Œæ›¿ãˆã‚‹ã¨å½“ç„¶ãã†ãªã‚‹
- æ³¨ç›®ã—ãªã‘ã‚Œã°ã„ã‘ãªã„ã®ã¯ã€Œæ˜‡é †ã«ãªã£ã¦ã„ã‚‹ç®‡æ‰€ã€ã ã£ãŸ(`v[1] < v[2]`)
- é…åˆ—ä¸­ã®ãã‚Œãã‚Œã®éš£ã‚Šåˆã£ãŸè¦ç´ ãŒæ˜‡é †ã§ã‚ã‚‹ã¨ãã€ãã®é…åˆ—ã¯æ˜‡é †ã 
    - æœ«å°¾ã«è¿‘ã„æ˜‡é †ã‚’å´©ã—ã¦ã„ãã“ã¨ã§æ¬¡ã®å½¢ãŒè¦‹ã¤ã‹ã‚‹

### å†å¸°é–¢æ•°ã‹ã‚‰ã®è„±å´

```rust
| 1,3,5,4,2 |
|   i   j   |
â†“
| 1,4,5,3,2 | â† äº¤æ›ç›´å¾Œ
| 1,4,2,3,5 | â† i+1 ä»¥é™é€†é †
```

- ç€ç›®ã™ã¹ãä½ç½® `i` ã¯ã€Œæœ«å°¾ã«è¿‘ã„æ˜‡é †ãªãƒšã‚¢ã®ã€å°ã•ã„æ–¹ã€ã«ãªã‚‹
    - ã¤ã¾ã‚Šã€æœ«å°¾ã«è¿‘ã„æ˜‡é †ã®ãƒšã‚¢ã‚ˆã‚Šå¾Œã‚ã¯ã€Œã™ã¹ã¦é™é †ã€ã§ã‚ã‚‹
- æœ«å°¾ã‹ã‚‰äº¤æ›ã™ã¹ãè¦ç´  `j` ã‚’æ¢ã™

```rust
fn permutations_core<T: Clone + Ord>(v: &mut Vec<T>) -> Vec<Vec<T>> {
    let l = v.len();
    if l <= 1 {
        return vec![v.clone()];
    }

    let mut res = Vec::new();

    let mut i = l - 1;
    loop {
        let ii = i;
        i -= 1;
        // æ˜‡é †ã®ç®‡æ‰€ã‚’æ¢ã™
        if v[i] < v[ii] {
            for j in (ii..l).rev() {
                // æ˜‡é †ãŒè¦‹ã¤ã‹ã£ãŸãªã‚‰å¿…ãšäº¤æ›ã§ãã‚‹
                if v[i] < v[j] {
                    res.push(v.clone());
                    v.swap(i, j);
                    v[ii..l].reverse();
                    break;
                }
            }
            // ã¾ãŸæœ«å°¾ã‹ã‚‰æ¢ã™
            i = l - 1;
            continue;
        }
        if i == 0 {
            break;
        }
    }
    res.push(v.clone());

    return res;
}
```

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¯æ”¹å–„ã—ãŸ

- `1.11s` ç¨‹åº¦ã«ã¾ã§æ”¹å–„ã•ã‚ŒãŸ


## next_permutation() ã«ã™ã‚‹

- å°‘ã€…æ•´ãˆã‚Œã° `next_permutation()` ã«ã§ãã‚‹

```rust
fn permutations<T: Clone + Ord + Debug>(v: Vec<T>) -> Vec<Vec<T>> {
    let mut v = v.clone();
    let mut res = Vec::new();

    res.push(v.clone());
    while let Some(next) = next_permutations(&v) {
        res.push(next.clone());
        v = next;
    }

    return res;
}
fn next_permutation<T: Clone + Ord>(v: &Vec<T>) -> Option<Vec<T>> {
    let mut v = v.clone();
    let l = v.len();
    if l <= 1 {
        return Some(v);
    }

    let mut i = l - 1;
    loop {
        let ii = i;
        i -= 1;
        // æ˜‡é †ã®ç®‡æ‰€ã‚’æ¢ã™
        if v[i] < v[ii] {
            for j in (ii..l).rev() {
                // æ˜‡é †ãŒè¦‹ã¤ã‹ã£ãŸãªã‚‰å¿…ãšäº¤æ›ã§ãã‚‹
                if v[i] < v[j] {
                    v.swap(i, j);
                    v[ii..l].reverse();
                    return Some(v);
                }
            }
        }
        if i == 0 {
            break;
        }
    }

    return None;
}
```

ã§ããŸã€‚`Vec` ã«ç”Ÿã‚„ã™ãªã‚Šã—ã¦ã‚‚ã‚ˆã„ã‹ã‚‚ã€‚

## ã‚€ã™ã³

- `permutations` ãŠã‚ˆã³ã€ `next_permutation` ã«ã¤ã„ã¦ç†è§£ã‚’æ·±ã‚ãŸ
- ã§ããŸã‚³ãƒ¼ãƒ‰ã¯ã‚¹ãƒ‹ãƒšãƒƒãƒˆã¨ã—ã¦æ´»ç”¨ã—ã¦ã„ã
    - ã¾ã æ—¢å­˜ã®å¤–éƒ¨crateã‚’ä½¿ã†ã»ã©é¦´æŸ“ã‚“ã§ã„ãªã„ãŸã‚


## å‚è€ƒ

- [cpprefjp - C++æ—¥æœ¬èªãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹](https://cpprefjp.github.io/index.html)
